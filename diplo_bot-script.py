#packages

import random
import time

#packages for the telegram bot

import logging
import telegram

from telegram import (ReplyKeyboardMarkup,InlineKeyboardMarkup, InlineKeyboardButton, ReplyKeyboardRemove)
from telegram.ext import (Updater, CommandHandler, MessageHandler, Filters, ConversationHandler, CallbackQueryHandler)

enable logging

logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
                    level=logging.INFO)

logger = logging.getLogger(__name__)

#instantiation of telegram and IBM api
#packages for the IBM tone analyzer


from ibm_watson import ToneAnalyzerV3
from ibm_cloud_sdk_core.authenticators import IAMAuthenticator

########################
#api identification and url of the telegram bot

telegram_bot_token = None
IBM_auth_token = None

bot_token = telegram_bot_token #the telegram api's unique key for diplo_tone_analyzer_bot
bot_url = "https://api.telegram.org/bot{}/".format(bot_token) #the url that is used for communication with diplo_tone_analyzer_bot

bot = telegram.Bot(token=bot_token)

###########
#api identification and url of the IBM tone analyzer

authenticator = IAMAuthenticator(IBM_auth_token)
toneAnalyzer = ToneAnalyzerV3(version="2017-09-21", authenticator=authenticator)
toneAnalyzer.set_service_url("")

#<instantiation of global variables, phrasewords, keyboards, states

#game data gets saved as a dictionary where information about the current game is saved as a entry with the chat_id of the player as key
#each entry is itself a dictionary with the following keys: bot_A, bot_B (instantiated in the function start_game); player_pos(instantiated in the function start_game); current bot (instantiated in start_game)

game_data = {}
current_bot = None

#emotions

emotions = ["anger", "fear", "joy", "sadness", "analytical", "confident", "tentative"]

#player starting starting position

player_starting_position = 1

#bot character collection

confident_and_analytical = [
"All warfare is based on deception.",
"Hence to fight and conquer in all your battles is not supreme excellence; supreme excellence consists in breaking the enemy's resistance without fighting.",
"Simulated disorder postulates perfect discipline, simulated fear postulates courage; simulated weakness postulates strength.",
"Then no man, however wise, will be able to avert the consequences that must ensue.",
"He who knows them not, nor practices them, will surely be defeated.",
"It is only one who is thoroughly acquainted with the evils of war that can thoroughly understand the profitable way of carrying it on.",
"To secure ourselves against defeat lies in our own hands, but the opportunity of defeating the enemy is provided by the enemy himself.",
"If he is secure at all points, be prepared for him.",
"Making no mistakes is what establishes the certainty of victory, for it means conquering an enemy that is already defeated.",
"You can be sure of succeeding in your attacks if you only attack places which are undefended.",
"By discovering the enemy's dispositions and remaining invisible ourselves, we can keep our forces concentrated, while the enemy's must be divided.",
"What we can do is simply to concentrate all our available strength, keep a close watch on the enemy, and obtain reinforcements.",
"He who exercises no forethought but makes light of his opponents is sure to be captured by them.",
"All men can see the tactics whereby I conquer, but what none can see is the strategy out of which victory is evolved.",
"This is a certain road to victory.",
]
just = [
"Nonviolence is absolute commitment to the way of love. Love is not emotional bash; it is not empty sentimentalism. It is the active outpouring of one’s whole being into the being of another.",
"He who is devoid of the power to forgive is devoid of the power to love.",
"Every man must decide whether he will walk in the light of creative altruism or in the darkness of destructive selfishness.",
"It is not enough to say we must not wage war. It is necessary to love peace and sacrifice for it.",
"If you can’t fly then run, if you can’t run then walk, if you can’t walk then crawl, but whatever you do you have to keep moving forward.",
"Everybody can be great … because anybody can serve. You don’t have to have a college degree to serve. You don’t have to make your subject and verb agree to serve. You only need a heart full of grace. A soul generated by love.",
"Those who are not looking for happiness are the most likely to find it, because those who are searching forget that the surest way to be happy is to seek happiness for others.",
"The art of acceptance is the art of making someone who has just done you a small favor wish that he might have done you a greater one.",
"The ultimate measure of a man is not where he stands in moments of comfort and convenience, but where he stands at times of challenge and controversy.",
"Not everybody can be famous but everybody can be great because greatness is determined by service… You only need a heart full of grace and a soul generated by love.",
"I refuse to accept the view that mankind is so tragically bound to the starless midnight of racism and war that the bright daybreak of peace and brotherhood can never become a reality… I believe that unarmed truth and unconditional love will have the final word.",
"It may be true that the law cannot make a man love me, but it can keep him from lynching me, and I think that’s pretty important.",
"World peace through nonviolent means is neither absurd nor unattainable. All other methods have failed. Thus we must begin anew. Nonviolence is a good starting point. Those of us who believe in this method can be voices of reason, sanity, and understanding amid the voices of violence, hatred, and emotion. We can very well set a mood of peace out of which a system of peace can be built."
]


#bot starting values

bot_A_name = "Django"
bot_A_emotions = [0, 1, 0.5, 0.5, 0.5, 0, 1]
bot_A_character = confident_and_analytical
bot_A_starting_trust = 0.4
bot_A_trust_upper_lim = 0.75
bot_A_trust_lower_lim = 0.25
bot_A_starting_position = 2

bot_B_name = "Martin Luther King"
bot_B_emotions = [0, 0, 1, 0.5, 0.5, 1, 0.5]
bot_B_character = just
bot_B_starting_trust = 0.5
bot_B_trust_upper_lim = 0.75
bot_B_trust_lower_lim = 0.25
bot_B_starting_position = 3

#possible moves dictionary

possible_moves = {
                1: [1,4,6],
                2: [2,4,5],
                3: [3,5,6],
                4: [1,2,4,5,6],
                5: [2,3,4,5,6],
                6: [1,3,4,5,6]
}

#states of the telegram bot

START, TURN, BOTCON, RESOLVETURN = range(4)

#starting keyboard

phrase_start = "Start a new game"
callback_data_start = "new_game"
callback_data_tutorial = "tutorial"
phrase_tutorial = "Tutorial"
phrase_end_game = "Quit Game"

start_keyboard = [[phrase_start, phrase_tutorial],
                [phrase_end_game]
]

start_markup = ReplyKeyboardMarkup(start_keyboard)

#in_turn keyboard

phrase_start_of_bot_reply = "Send Message to bot "

phrase_bot_A_reply = phrase_start_of_bot_reply+bot_A_name
phrase_bot_B_reply = phrase_start_of_bot_reply+bot_B_name
phrase_quit_game = "Quit Game"
phrase_end_turn = "End turn"

turn_markup = ReplyKeyboardMarkup([[phrase_bot_A_reply, phrase_bot_B_reply],
                                     [phrase_end_turn, phrase_quit_game]]
)

#commands keyboard

keyboard_moves = list(InlineKeyboardButton(i,callback_data=str(i)) for i in range(1,7))

moves_markup = InlineKeyboardMarkup([keyboard_moves])

#return to menu keyboards

phrase_return = "Return to menu"

keyboard_return = [[phrase_return]]

return_markup = ReplyKeyboardMarkup(keyboard_return)

#IBM tone analyzer functions

#this function does analyze text in one of the following formats: json, plain text or html
#it returns it as a dictionary of tone scores for anger, fear, joy, sadness, analytical, confident, tentative
#more information at https://cloud.ibm.com/docs/services/tone-analyzer?topic=tone-analyzer-utgpe
#NOTE: There is only one emotion assigned to every sentence. These emotions are used for the documents emotions.
#[var=(text), return=(js), pckg=(), func=(toneAnalyzer)]

def extract_emotions(text):

    try:
        tone_analysis = toneAnalyzer.tone(
            {"text": text},
            sentences = False
        ).get_result()
        emotion_dict = dict(zip(emotions,[0,0,0,0,0,0,0]))
        emotion_dict.update({tone["tone_id"]:tone["score"] for tone in tone_analysis["document_tone"]["tones"]})

        return emotion_dict
    except Exception as ex:
        print("Method failed with status code " + str(ex.code) + ": " + ex.message)

# DON'T USE THIS FUNCTION AS THE ANALYSIS IS NOT THE EMOTIONS WE WANT
#this function does analyze chat content in a format that has to be looked up at https://cloud.ibm.com/docs/services/tone-analyzer?topic=tone-analyzer-utco&locale=de
#it returns it as a dictionary that assigns one definite emotion to each chat entry
#[var=(chat), return=(tone_analysis), pckg=(), func=(toneAnalyzer)
def analyze_chat(chat):

    try:
        tone_analysis = toneAnalyzer.tone_chat(chat).get_result()
        return tone_analysis
    except Exception as ex:
        print("Method failed with status code " + str(ex.code) + ": " + ex.message)

#npc scripts

def start_game(update,context):

    player_id = update.message.chat_id

    game_data.update({player_id:{}})

    bots = {
            bot_A_name: ki_bot(bot_A_name,bot_A_emotions,bot_A_starting_position,bot_A_starting_trust,bot_A_trust_upper_lim,bot_A_trust_lower_lim,bot_A_character),
            bot_B_name: ki_bot(bot_B_name,bot_B_emotions,bot_B_starting_position,bot_B_starting_trust,bot_B_trust_upper_lim,bot_B_trust_lower_lim,bot_B_character)
    }

    game_data[player_id].update({"developer":False})
    game_data[player_id].update(bots)
    game_data[player_id].update({"pos_player": player_starting_position})
    game_data[player_id].update({"current_bot": None})

    message_start_1 = "Welcome to our Diplo-Bot, the Bot to learn about Cooperation and Trustbuilding."
    message_start_2 = "Do you want to start a new game, then click on 'Start a new game'."
    message_start_3 = "Do you need additional information on how to use Diplo-Bot, then click on 'Tutorial'."

    start_messages = [message_start_1,message_start_2,message_start_3]

    for message in start_messages:
        bot.send_message(
                    chat_id=player_id,
                    text=message,
                    reply_markup=start_markup
        )
        time.sleep(0.5)

    return START

def tutorial(update,context):

    player_id = update.message.chat_id

    message_tutorial = "Welcome to our tutorial."
    message_tutorial_2 = "Click on 'Start a new game' if you want to start the game."
    message_tutorial_3 = "When you started a new game, you can chat with your two opponents 'Django' and 'Martin Luther King', convince them by satisfying their emotional profile. They will give you a response informing you, if you met their expectations. If you convinced them or they do not trust you anymore, they will let you know and you have to wait until the next round to write them again. After you chatted with your opponents, you can end the turn and enter you commands for the turn. Then the moves are calculated and you can begin with the next turn. Two players win, if they cornered the third player, such that he can not move anymore and they move together on his field. So try to find a reliable partner."
    message_tutorial_4 = "This is the map. You will start on position 1, Django on position 2, Martin Luther King on position 3. You can move to one of the neighboring fields in each turn."
    tutorial_messages = [message_tutorial, message_tutorial_3]

    for message in tutorial_messages:

        bot.send_message(
                        chat_id=player_id,
                        text=message,
                        reply_markup=start_markup
        )
        time.sleep(0.5)

    time.sleep(1)

    bot.send_message(
                    chat_id=player_id,
                    text=message_tutorial_4,
                    reply_markup=start_markup
    )

    time.sleep(1)

    bot.send_photo(
                chat_id=player_id,
                photo=open('diplo_map.png', 'rb')
    )

    time.sleep(1)

    bot.send_message(
                    chat_id=player_id,
                    text=message_tutorial_2,
                    reply_markup=start_markup
    )

    return START

def start_new_game(update,context):

    player_id = update.message.chat_id
    
    message_new_game = "You started a new game. You are on position 1, Django is on position 2 and Martin Luther King is on position 3."

    bot.send_message(
                    chat_id=player_id,
                    text=message_new_game,
                    reply_markup=turn_markup
    )

    bot.send_photo(
                chat_id=player_id,
                photo=open('diplo_map.png', 'rb')
    )

    message_game_move = "Do you want to chat with one of your opponents? Or do you want to end the turn?"

    bot.send_message(
                    chat_id=player_id,
                    text=message_game_move,
                    reply_markup=turn_markup
    )

    return TURN

#functions to process communication with one of the bots

def enter_bot_con(update,context):

    player_id = update.message.chat_id

    bot_name = update.message.text[len(phrase_start_of_bot_reply):]
    game_data[player_id]["current_bot"] = game_data[player_id][bot_name]
    current_bot = game_data[player_id]["current_bot"]

    message_i_am = "Hi I am " + str(bot_name) + "."
    message_my_position = " My current position is on field " +str(current_bot.position)

    bot.send_message(
                chat_id=player_id,
                text=message_i_am
    )

    time.sleep(1)

    bot.send_message(
                chat_id=player_id,
                text=message_my_position
    )

    time.sleep(0.5)

    bot.send_photo(
                chat_id=player_id,
                photo=open('diplo_map.png', 'rb')
    )

    time.sleep(1)

    message_enter_con = "Where do you want me to move?"

    bot.send_message(
                chat_id=player_id,
                text=message_enter_con,
                reply_markup=moves_markup
    )

    return BOTCON

def first_response_bot_con(update,context):

    query = update.callback_query
    player_id = query.message.chat.id
    current_bot = game_data[player_id]["current_bot"]

    message_first_response = "So you want me to move to field " + query.data + "?"

    current_bot.wished_move = int(query.data)

    print(game_data)

    bot.send_message(
                chat_id=player_id,
                text=message_first_response,
                reply_markup=return_markup
    )

    message_next_step = "Why should I comply with what you want?"

    bot.send_message(
                chat_id=player_id,
                text=message_next_step
    )

    return BOTCON

def bot_con(update,context):

    player_id = update.message.chat_id
    current_bot = game_data[player_id]["current_bot"]

    message_character = random.choice(current_bot.character)

    bot.send_message(
                    chat_id=player_id,
                    text=message_character
    )

    current_bot.evaluate_emotions_answer(update,context)

    message_no_trust = "I don't trust you no more. Maybe we can come to an agreement next turn."
    message_full_trust = "I am convinced, I will move as you said, we can talk next turn again."

    if current_bot.trust_upper_lim <= current_bot.trust:

        bot.send_message(
                        chat_id=player_id,
                        text=message_full_trust,
                        reply_markup=turn_markup
        )
        return TURN

    elif current_bot.trust_lower_lim > current_bot.trust:

        bot.send_message(
                        chat_id=player_id,
                        text=message_no_trust,
                        reply_markup=turn_markup
        )

        return TURN

    return BOTCON

def leave_bot_con(update,context):

    player_id = update.message.chat_id
    current_bot = game_data[player_id]["current_bot"]

    message_leave_con = "So we finished our conversation? I hear from you again!"

    bot.send_message(
                chat_id=player_id,
                text=message_leave_con,
                reply_markup=turn_markup
    )

    game_data[player_id][current_bot.name] = current_bot

    return TURN

#used for calculation on the end of turn

def end_turn(update,context):

    player_id = update.message.chat_id

    message_current_position = "Your are currently on field "+str(game_data[player_id]["pos_player"])

    message_end_turn = "To which field do you want to move? Choose below."

    bot.send_message(
                chat_id=player_id,
                text=message_current_position
    )

    bot.send_message(
                chat_id=player_id,
                text=message_end_turn,
                reply_markup=moves_markup
    )


    bot.send_photo(
                chat_id=player_id,
                photo=open('diplo_map.png', 'rb')
    )

    return RESOLVETURN

def evaluate_commands(update,context):

    query = update.callback_query
    player_id = query.message.chat_id

    position_player = game_data[player_id]["pos_player"]
    position_bot_A = game_data[player_id][bot_A_name].position
    position_bot_B = game_data[player_id][bot_B_name].position


    if int(query.data) in possible_moves[position_player]:
        """make exception if query.data is no possible move"""

        move_player = int(query.data)
    else:
        message_wrong_commands = "This move is not possible, choose another one."

        bot.send_message(
                    chat_id=player_id,
                    text=message_wrong_commands
        )
        return RESOLVETURN

    move_bot_A = game_data[player_id][bot_A_name].calc_move_decision()
    move_bot_B = game_data[player_id][bot_B_name].calc_move_decision()

    supposed_moves = ((position_player, move_player), (position_bot_A, move_bot_A), (position_bot_B, move_bot_B))

    if game_data[player_id]["developer"]:
        message_supposed_moves = "This are the moves that you chose: "
        bot.send_message(
                        chat_id=player_id,
                        text=str(supposed_moves)
        )

    new_positions = resolve_moves(position_player, move_player, position_bot_A, move_bot_A, position_bot_B, move_bot_B)
    #new_positions = resolve_moves(supposed_moves)

    # quit game if one player lost
    for position in new_positions:
        if position == 0:
            looser = new_positions.index(position)

            if looser == 0:
                message_player_lost = "Game over! \n It seems your opponents defeated you. Try another time, by pressing 'Start a new game'."
            else:
                message_player_lost = "Victory! \n You and your ally won. Good job, it seems you learned how to cooperate emotionally. If you want to play another round, press 'Start a new game'."

            bot.send_message(
                        chat_id=player_id,
                        text=message_player_lost,
                        reply_markup=start_markup
            )

            return START

    game_data[player_id]["pos_player"] = new_positions[0]
    game_data[player_id][bot_A_name].position = new_positions[1]
    game_data[player_id][bot_B_name].position = new_positions[2]

    message_tried_commands = "You tried to move from "+str(position_player)+" to "+str(move_player)+". "+str(bot_A_name)+" tried to move from "+str(position_bot_A)+" to "+str(move_bot_A)+". "+str(bot_B_name)+" tried to move from "+str(position_bot_B)+" to "+str(move_bot_B)+"."
    #send map
    bot.send_message(
                chat_id=player_id,
                text=message_tried_commands
    )
    message_commands_processed = "These are the new positions: You are on position " + str(new_positions[0]) + ". Django is on position " + str(new_positions[1]) + ". Martin Luther King is on position " + str(new_positions[2]) + "."

    bot.send_message(
                chat_id=player_id,
                text=message_commands_processed
    )
    bot.send_photo(
                chat_id=player_id,
                photo=open('diplo_map.png', 'rb')
    )

    game_data[player_id][bot_A_name].trust = (game_data[player_id][bot_A_name].trust + 0.5) / 2
    game_data[player_id][bot_B_name].trust = (game_data[player_id][bot_B_name].trust + 0.5) / 2

    return TURN

def resolve_moves(pos_player, move_player, pos_bot_A, move_bot_A, pos_bot_B, move_bot_B):

    moves=[move_player,move_bot_A,move_bot_B]
    pos=[pos_player,pos_bot_A,pos_bot_B]

#this whole junk is to implement in-game diplomacy logic, "0" mean this player lost.

    if len(set(moves))==3:                                                              #if all move to different positions
        return moves                                                                        #then everything resolves
    elif len(set(moves))==1:                                                            #if all move to one position
        if moves[0] in pos:                                                                  #suppose this position is a occupied one, then the player on it loses
            pos[pos.index(moves[0])] = 0
            return pos
        else:                                                                                #otherwise all moves are stopped
            return pos
    else:                                                                               #third option: two move to the same position and the last one doesn't
        new_moves = moves
        for i in range(0,2):                                                            #we have to find out, which are which
            for j in range(i+1,3):
                if moves[i]==moves[j]:                                                  #this if-condition does
                    last_one = [0,1,2]                                                  #mark the last remaining
                    last_one.remove(i)
                    last_one.remove(j)
                    new_moves[i] = pos[i]
                    new_moves[j] = pos[j]
                    if moves[last_one[0]]==pos[i] or moves[last_one[0]]==pos[j]:        #if he is moving to the position of the other twos
                        if pos[last_one[0]]==moves[i]:                                      #then either he was on the position the both attacked and he loses
                            new_moves[last_one[0]] = 0
                        else:                                                               #or he will simply be stopped
                            new_moves[last_one[0]] = pos[last_one[0]]
        return new_moves

def quit_game(update,context):

    player_id = update.message.chat_id

    message_quit_game = "you quited the game"

    bot.send_message(
                chat_id=player_id,
                text=message_quit_game
    )

    message_start = "What do you want to do?"

    bot.send_message(
                    chat_id=player_id,
                    text=message_start,
                    reply_markup=start_markup
    )

    return START

def developer(update,context):
    """Enters developer mode"""
    player_id = update.message.chat_id

    message_developer = "You entered developer mode"
    game_data[player_id]["developer"] = not game_data[player_id]["developer"]


    bot.send_message(
                    chat_id=player_id,
                    text=message_developer
    )

    return START

def error(update, context):
    """Log Errors caused by Updates."""
    logger.warning('Update "%s" caused error "%s"', update, context.error)

    return START

def done(update, context):
    user_data = context.user_data

    user_data.clear()


    return ConversationHandler.END

class ki_bot:

    def __init__(self,name,emotion_values,starting_position,starting_trust,trust_upper_lim,trust_lower_lim,character):

        self.name = name
        self.values = dict(zip(emotions,emotion_values))
        self.character = character
        self.trust = starting_trust
        self.trust_upper_lim = trust_upper_lim
        self.trust_lower_lim = trust_lower_lim
        self.position = starting_position
        self.wished_move = None

    def evaluate_emotions_answer(self,update,context):

        evaluation = 0

        player_id = update.message.chat_id

        message = update.message.text

        emotions_detected = extract_emotions(message)

        if game_data[player_id]["developer"]:
            message_values = "This are my values: "
            message_your_emotions = "This are your emotions: "

            bot.send_message(
                            chat_id=player_id,
                            text=message_values+str(self.values)
            )
            bot.send_message(
                            chat_id=player_id,
                            text=message_your_emotions+str(emotions_detected)
            )

        matched_emotions = {}
        matched_emotions_abs = {}

        for emotion in emotions_detected:
            matched_emotions[emotion] = self.values[emotion]-emotions_detected[emotion]
            matched_emotions_abs[emotion] = abs(self.values[emotion]-emotions_detected[emotion])
            if abs(matched_emotions[emotion]) <= 0.5:
                evaluation += 1

        worst_match_emotion = max(matched_emotions_abs, key=matched_emotions_abs.get)
        worst_value_emotion = matched_emotions[worst_match_emotion]

        if worst_match_emotion == "analytical":
            worst_match_emotion = "analyticality"
        elif worst_match_emotion == "confident":
            worst_match_emotion = "confidence"
        elif worst_match_emotion == "tentative":
            worst_match_emotion = "tenativeness"

        if worst_value_emotion >= 0:
            message_correct_emotion = "I would be more convinced, if you would show more " + str(worst_match_emotion)
        elif worst_value_emotion < 0:
            message_correct_emotion = "I would be more convinced, if you would show less " + str(worst_match_emotion)

        bot.send_message(
                        chat_id=player_id,
                        text=message_correct_emotion
        )

        evaluation = evaluation / 7

        if game_data[player_id]["developer"]:

            bot.send_message(
                            chat_id=player_id,
                            text="evaluation value: "+str(evaluation)
            )

        message_neg = "I am getting sceptical about your intentions."
        message_pos = "But this seems to be a valid point."
        message_neu = "But you have good points, please elaborate your idea."


        if self.trust > evaluation:
            message_return = message_neg

        elif self.trust < evaluation:
            message_return = message_pos

        elif self.trust == evaluation:
            message_return = message_neu

        bot.send_message(
                        chat_id=player_id,
                        text=message_return
        )

        self.trust = (self.trust + evaluation) / 2

        if game_data[player_id]["developer"]:
            bot.send_message(
                            chat_id=player_id,
                            text="This is my new trust value: " + str(self.trust)
            )

    def calc_move_decision(self):

        decision = self.position

        if self.trust > self.trust_upper_lim and self.wished_move in possible_moves[self.position]:
            decision = self.wished_move
        else:
            decision = random.choice(possible_moves[self.position])

        return decision

#mainfunction

def main():

    updater = Updater(bot_token,use_context=True)

    dp = updater.dispatcher

    con_handler = ConversationHandler(
        entry_points = [CommandHandler('start', start_game)],
        states = {
            START: [MessageHandler(Filters.regex(phrase_start),start_new_game),
                    MessageHandler(Filters.regex(phrase_tutorial),tutorial),
                    MessageHandler(Filters.regex(phrase_end_game),done)
            ],
            TURN: [MessageHandler(Filters.regex(phrase_bot_A_reply),enter_bot_con),
                    MessageHandler(Filters.regex(phrase_bot_B_reply),enter_bot_con),
                    MessageHandler(Filters.regex(phrase_quit_game),quit_game),
                    MessageHandler(Filters.regex(phrase_end_turn),end_turn)
            ],
            BOTCON: [CallbackQueryHandler(first_response_bot_con,pattern=key["callback_data"]) for key in keyboard_moves]
                    +
                    [MessageHandler(Filters.regex(phrase_return),leave_bot_con),
                    MessageHandler(Filters.regex(""),bot_con)
            ],
            RESOLVETURN: [MessageHandler(Filters.regex("^continue$"),evaluate_commands)]
                    +
                    [CallbackQueryHandler(evaluate_commands,pattern=key["callback_data"]) for key in keyboard_moves
            ]
        },
        fallbacks = [CommandHandler('developer', developer),
                    MessageHandler(Filters.regex("^done$"),done)
        ]
    )

    dp.add_handler(con_handler)

    # log all errors
    dp.add_error_handler(error)

    #Start the Bot
    updater.start_polling()

    # Run the bot until you press Ctrl-C or the process receives SIGINT,
    # SIGTERM or SIGABRT. This should be used most of the time, since
    # start_polling() is non-blocking and will stop the bot gracefully.
    updater.idle()

if __name__ == '__main__':
    main()
